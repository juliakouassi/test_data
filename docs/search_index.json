[["index.html", "Data Literacy Test Chapter 1 Setup 1.1 Grundfähigkeiten 1.2 Lokale Installation 1.3 Quellen und Literatur 1.4 Installation von Programmbibliotheken 1.5 Grundregeln Markdown", " Data Literacy Test Julia Kouassi 2022-02-14 Chapter 1 Setup Sie sollten über einen Computerzugriff mit Admin-Rechten und einem aktuellen Betriebssystem verfügen. Ob Sie Windows, Mac OS oder Linux verwenden spielt keine Rolle, sofern Sie die Admin-Rechte haben und Programme selbstständig installieren können. Als Mindestausstattung sollten 4GB RAM und 2 GB Festplattenspeicher für die Programminstallation zur Verfügung stehen. 1.1 Grundfähigkeiten Sie sollten in der Lage sein, Ordner- und Dateistrukturen auf ihrem Laptop anzulegen. Idealerweise haben Sie dazu Adminstrationstrechte auf ihrem Laptop. 1.1.1 Dateien speichern und verwalten Wählen Sie die zu speichernde Datei mit einem Rechtsklick aus und wählen im Kontext-Menü: Speichern unter Empfehlenswert ist ein sinnvoller Speicherort (Ordner, Dateistruktur). Achten Sie auf folgende Punkte: Einheitliche Dateinamen, z.B. YYYY-MM-TT_Modulnummer_Detail.XXX Dateinamen sollten aussagekräftig sein, also nicht nur Abgabe oder final. Verwenden Sie keine Sonderzeichen für Dateinamen, Objekte und Variablen. 1.2 Lokale Installation Wir arbeiten mit folgenden Programmen, die lokal auf ihrem Laptop installiert sein müssen. Chromebooks funktionieren nur eingeschränkt, Tablets gar nicht. Sie können sich einen Laptop aus der Bibliothek ausleihen oder alternativ RStudio-Cloud verwenden. Wir verwenden nur open-source und gemeinfreie Software, d.h. der Quellcode ist offen gelegt und es werden keine Daten gesammelt (Ausnahme: Google/Twitter-Account). R (Version &gt; 4.1) RStudio (Version &gt; 4.1) Pandoc Texteditor (Atom.io oder ähnliches: hier kommt es auf persönliche Präferenzen an. Achtung: ein Editor ist etwas anderes wie Word oder Open-Office: hier wird Text oder Code direkt bearbeitet und keine grafische Benutzeroberfläche darübergelegt) Browser (Firefox oder Brave) Github-Account (Empfehlung: HdM-Kürzel verwenden) Google-Account (Empfehlung: neuer Account mit HdM-Kürzel) Optional: LaTex-Installation für die Erstellung von PDF-Dokumenten Optional: Twitter-Account (für die Datenanalyse, Empfehlung: HdM-Kürzel) Optional: RStudioCloud-Account Sollten Sie keinen Laptop haben oder die Programme nicht installieren können, lässt sich RStudioCloud alternativ verwenden. 1.3 Quellen und Literatur Es gibt viele (kostenlose) Tutorials, Videos und Online-Kurse, die vertiefend verwendet werden können. Drei Angebote halte ich für besonders hilfreich: Zum Nachschlagen: Wickham, H. &amp; Grolemund, G. (2017). R for Data Science. Es gibt von OReilly eine deutsche Ausgabe, das Buch ist ein Klassiker und direkt vom Entwickler des tidyverse Konzepts geschrieben. Es deckt den gesamten Workflow ab. Wright, C., Ellis, S.E., Hicks, C. &amp; Peng, R.D. (2021). Tidyverse Skills for Data Science. Sehr gute, praxisorientierte Zusammenfassung der wichtigsten Skills (englishsprachig). Ellis, A. &amp; Mayer, B. (2021). Einführung in R. Kompakte, deutschsprachige Einführung in die wichtigsten Funktionen. Selbstlernangebote (interaktiv) RStudio Primers. Diese Selbstlerneinheiten sind 1.4 Installation von Programmbibliotheken Wir verwenden folgende Programmbibliotheken in der aktuellsten Version rmarkdown tidyverse ggplot2 In wenigen Fällen kommt es beim Paket tidyverse zu Installationsfehlern, weil manche Pakete für manche Betriebssysteme (Linux) noch nicht aktualisiert waren. Hier ist es sinnvoll, die einzelnen Pakete des tidyverse einzeln zu installieren. 1.5 Grundregeln Markdown Wir verwenden die Auszeichnungssprache RMarkdown, die in RStudio 1.4 als Visual Markdown implementiert wurde. Mit Visual Markdown lassen sich ganz einfach zwischen dem Markdown-Code und der Repräsentation hin und her wechseln. Der Befehl dazu ist ganz rechts als Icon in der Menüleiste abgelegt. Eine gute Übersicht ist unter &lt;http://rmarkdown.rstudio.com&gt; abgelegt, Cheatsheet Markdown. 1.5.0.1 YAML Als YAML wird der Header (Kopf) eines Markdown-Dokuments bezeichnet, in dem die Formatierung und Ausgabe des Dokuments festgelegt werden. Die meisten YAML-Konfigurationen sind bereits angelegt und definieren den Autor und Titel des Dokuments. YAML wird dann relevant, wenn mit dem Paket knitr das Markdown-Dokument in weitere Formate wie HTML, Word oder PDF exportiert wird. Code, Layout und Inhalt Ein Grundprinzip von Markdown ist es, Inhalt, Layout und Code voneinander zu trennen. Das bedeutet, dass der gesamte Inhalt als einfacher Text zu lesen ist, egal von welchen Endgerät (im Gegensatz etwa zu Textverarbeitungen wie MS Word oder Layout-Programmen). Damit ist sichergestellt, dass sich die Inhalte weiterverwenden lassen. Die Auszeichnungsformate für die Formatierung wie etwa Überschriften oder Fettungen werden automatisch ausgelesen und entsprechend umgesetzt. Teilweise lassen sich auch visuelle Editoren verwenden (z.B. Visual Markdown Editor in RStudio). Diese übersetzen die Auszeichungen in Echtzeit in die Darstellung und lassen so ein ähnliches Arbeiten wie in Word. Code-Chunks Code Chunks sind konfigurierbare und ausführbare Code-Schnipsel. Damit lässt sich Programmcode direkt in einem Dokument ausführen. Das hat mehrere Vorteile. Der Wechsel zwischen Programmierumgebung und Dokument/Erläuterung entfällt. Der Datenbestand im Dokument ist immer aktuell. Veränderungen in den Daten werden auf das gesamte Dokument übertragen. Variablen bzw. deren Ergebnisse lassen sich direkt im Text einbetten. Das Dokument ist für Dritte reproduzierbar, sofern die Datenquelle in einem Online-Verzeichnis liegt und daher leicht austauschbar. Jeder Code-Chunk benötigt a) einen eindeutigen Namen (keine Sonderzeichen) und b) kann individuell eingestellt werden: echo = FALSE: es wird kein Code ausgegeben, nur das Ergebnis angezeigt message = TRUE: zeigt alle Meldungen an, FALSE verhindert das. paged.print=TRUE: liefert den Output auf mehreren Seiten fig.height=6, fig.width=9: Höhe und Breite der Visualisierung in inch. Grafiken einbetten Häufig visualisieren wir Daten. Diese lassen sich als Output direkt in einem Code-Chunk generieren. Wenn nur eine Abbildung gezeigt werden soll ist es hilfreich, den Codechunk auf Echo=FALSE zu stellen, damit nur die Abbildung im Text angezeigt wird. Verweise im Text Sind Objekte im Code definiert, lassen sich diese im Text direkt referenzieren. # Wir erstellen ein Objekt mit der Bezeichnung age_anton, das in diesem Beispiel berechnet wird anton &lt;- 2001 # Geburtsjahr von Anton age_anton &lt;- 2021-anton # Alter von Anton age_anton ## [1] 20 plus &lt;- 5 age_anton_plus &lt;- age_anton + plus # Das Objekt age_anton lässt sich nun durch `r age_anton` direkt im Markdown-Text einbetten. Wichtig dafür sind die entsprechenden Zeichen, die &quot;backticks&quot; heißen. Wenn das Dokument entsprechend umgewandelt wird, z.B. als HTML, dann werden auch die Variablenwerte im Text entsprechend verändert. Anton ist 20 Jahr alt. Anton wird in 5 Jahren age_anton_plus Jahre alt sein. Die Werte werden erst ersetzt, wenn das Dokument durch knitr in einem anderen Format wie etwa HTML ausgegeben werden. "],["grundlegende-funktionen.html", "Chapter 2 Grundlegende Funktionen 2.1 Grundfunktionen in R", " Chapter 2 Grundlegende Funktionen Die Welt von R besteht aus Objekten, Funktionen und Argumenten. Das ist ähnlich wie bei der Grammatik mit Objekten, Verben und Adverben. Prinzipiell werden alle Daten als Objekte behandelt, die durch Funktionen, also verbalisierte Befehle verändert werden können und sich mit Argumenten präziser beschrieben lassen. Ergebnisse werden bei R entweder in der Konsole als Code-Ausgabe oder im Code-Chunk angezeigt. In der Konsole wird jedem ausgeführten Befehl die [1] vorangestellt. Das kann verwirrend sein, wenn mehrere Befehle ausgeführt werden. Deshalb empfiehlt es sich, mehrere Funktionen zusammenzufassen oder im Chunk auszuführen. 2.1 Grundfunktionen in R 2.1.0.1 Working Directory In der Working Directory, dem Arbeitsverzeichnis, werden automatisch die Dateien gespeichert. Es empfiehlt sich, das Arbeitsverzeichnis der Aufgabe entsprechend anzulegen und dort auch die Datenquellen abzulegen. Projekte Projekte speichern die Working Directory, die daran vorhandenen Dateien sowie offene Arbeitsprozesse. Dies eignet sich besonders für umfangreichere Projekte. 2.1.1 Daten sichern Wir arbeiten in der Regel mit Markdown-Dokumente, d.h. der Code ist direkt ins Dokument eingebettet. Manchmal ist es aber notwendig, bestimmte Daten in einem anderen Format zu sichern. Dazu lassen sich Daten speichern. 2.1.2 Grundrechenarten Mit R können alle Grundrechenarten ausgeführt werden und nach Regeln verknüpft werden, Cheatsheet base-r (PDF) # Addition 1+2 ## [1] 3 # Substraktion 15-3 ## [1] 12 # Multiplikation 2*3 ## [1] 6 # Division 64/8 ## [1] 8 # Verknüpfung einzelner Befehle (Klammerregeln beachten) (2+4) * (2) / 3 ## [1] 4 2.1.3 Zuweisungen und Variablen Prinzipiell können Variablen nicht nur eine natürliche Zahl, sondern auch Text oder anderen Datentypen umfassen. Allerdings lassen sich unterschiedliche Datentypen nicht miteinander verarbeiten, z.B. lässt sich eine Zahl nicht durch einen Text teilen. Objekte lassen sich durch den Zuweisungsbefehl &lt;- erstellen. Das bedeutet, dass einem Objekt ein bestimmter Wert zugeordnet wird. Das können natürliche Zahlen oder Texte sein. Objekte wiederum lassen sich direkt aufrufen oder weiter mit Funktionen verarbeiten. Funktionen funktionieren wie Verben, die einem Objekt sagen, was sie tun sollen. # Text muss immer in Anführungszeichen als Objekt verwendet werden alter &lt;- 21 name &lt;- &quot;Paul&quot; # Einzelne Objekte alter ## [1] 21 name ## [1] &quot;Paul&quot; # Fehler beim Versuch, eine Funktion auszuführen # name/alter 2.1.4 Was ist guter Code? Ein paar Grundregeln helfen, sich in R zurechtzufinden. Erst denken, dann coden: Zunächst über das Problem, das sie lösen wollen, nachdenken. Manchmal hilft dazu eine Skizze, um Abhängigkeiten und Schritte zu klären. Zerlegen Sie das Problem in überschaubare Schritte. Dann wird jedes Problem meist einfacher. Vor allem lässt sich jeder Schritt zurückverfolgen. Code annotieren: guter Code ist annotiert, d.h. es ist jederzeit für die Autoren aber auch für Dritte nachvollziehbar, welche Codeschritte gemacht wurden. Diese Annotation findet direkt im Chunk mit der Raute # statt. Eindeutige Bezeichnungen für Objekte: Objekte sollten immer eindeutig sein. Bewährt haben sich Unter_striche, um Objekte zu präzisieren. Vermeiden Sie Leerzeichen bei der Bezeichnung von Variablen. Lange Namen vermeiden und ggf. eine Annotation festlegen. Code reproduzierbar machen: Jeder Code muss reproduzierbar sein und zu gleichen Ergebnissen kommen. Mit dem Paket reprex lassen sich reproducible examples erstellen. Einfach statt verschachteln: Je nachvollziehbarer der Code ist, desto besser lassen sich Probleme vermeiden. Nutzen Sie dazu logische Operatoren und die Pipe %&gt;%. Einfacher Code ist auch eleganter Code: Guter Code folgt gewissen ästhetischen Grundregeln und ist auch für Menschen lesbar, d.h. in der Regeln wird für jede neue Funktion eine neue Zeile gewählt, die Pipe immer ans Ende der Zeile gestellt. 2.1.5 Datentypen Daten können unterschiedliche Formate annehmen. Die wichtigsten sind numerisch (numerical) und text (string/character) oder logisch (logical). Numerische Daten werden in integer (ganze natürliche Zahlen, z.B. 4, 12 und double (Zahlenwerte mit Dezimalen, etwa 12.42). Daten des gleichen Typs lassen sich über die c() Funktion in Vektoren zusammenfassen. # Datentypen lasen sich einfach überprüfen. # Schreibweisen beachten is_numeric(12) # natürliche Zahlen ## Warning: Deprecated ## [1] TRUE is_character(&quot;Joe&quot;) # Text immer in Anführungszeichen ## [1] TRUE is_logical(FALSE) # Logische Operatoren immer in CAPS (Großbuchstaben) ## [1] TRUE # Vectoren fassen verschiedene Daten des gleichen Typs zusammen: # numerischer Vector age &lt;- c(19, 20, 25, 31) age ## [1] 19 20 25 31 # Überprüfung des Vectors is_character(age) ## [1] FALSE is_numeric(age) ## Warning: Deprecated ## [1] TRUE # Vector aus Textdaten names &lt;- c(&quot;Miri&quot;,&quot;Johanna&quot;,&quot;Egon&quot;,&quot;Amir&quot;) names ## [1] &quot;Miri&quot; &quot;Johanna&quot; &quot;Egon&quot; &quot;Amir&quot; # Mit numerischen Vektoren lassen sich alle mathematischen Operationen durchführen. Dabei wird jeder Wert einzeln berechnet. age/2 * 20 ## [1] 190 200 250 310 2.1.6 Listen, Faktoren und Data Frames Häufig werden unterschiedlichen Datentypen gemeinsam verwendet. Dazu werden v.a. Listen eingesetzt. Listen können (müssen aber nicht) unterschiedliche Datentypen beinhalten. Faktoren hingegen verwenden unterschiedliche Datentypen und verbinden diese miteinander. # Einzelne Vectoren mit Daten age &lt;- c(19,20,25,31) weight &lt;- c(50,52,68,76) height &lt;- c(162,168,177,182) names &lt;- c(&quot;Miri&quot;,&quot;Johanna&quot;,&quot;Egon&quot;,&quot;Michel&quot;) sex &lt;- c(&quot;female&quot;,&quot;female&quot;,&quot;male&quot;,&quot;diverse&quot;) semester &lt;- c(2,2,1,4) study &lt;- c(&quot;PR&quot;,&quot;PR&quot;,&quot;CR&quot;,&quot;CR&quot;) # Ein Vektor lässt sich direkt aufrufen und liefert dann die Werte des Vektors study ## [1] &quot;PR&quot; &quot;PR&quot; &quot;CR&quot; &quot;CR&quot; sex ## [1] &quot;female&quot; &quot;female&quot; &quot;male&quot; &quot;diverse&quot; # erstelle einzelne Vektoren profs &lt;- c(&quot;Bader&quot;, &quot;Rinsdorf&quot;, &quot;Kamps&quot;) modul &lt;- c(226305, 226308) # führe die Vektoren unterschiedlicher Werte zusammen prof_modul &lt;- list(profs, modul) # Ruft die Liste mit den zuvor erstellen Werten auf prof_modul ## [[1]] ## [1] &quot;Bader&quot; &quot;Rinsdorf&quot; &quot;Kamps&quot; ## ## [[2]] ## [1] 226305 226308 Dataframes Dataframes sind einfache Verbindungen zwischen zwei oder mehreren Werten, die tabellarisch erstellt werden. Mit dem $-Operator lassen sich einzelne Spalten aufrufen. # einfachen Dataframe erstellen mit zwei Spalten age_weight &lt;- data.frame(age,weight) age_weight ## age weight ## 1 19 50 ## 2 20 52 ## 3 25 68 ## 4 31 76 # umfangreicherer dataframe students &lt;- data.frame(age,weight,height,names,sex,semester,study) students ## age weight height names sex semester study ## 1 19 50 162 Miri female 2 PR ## 2 20 52 168 Johanna female 2 PR ## 3 25 68 177 Egon male 1 CR ## 4 31 76 182 Michel diverse 4 CR # Teile eines bestehenden Datenframes zu einem neuen Datenframe zusammenfügen # der $-Operator liefert die entsprechenden Daten name_study &lt;- data.frame(students$names, students$study) name_study ## students.names students.study ## 1 Miri PR ## 2 Johanna PR ## 3 Egon CR ## 4 Michel CR 2.1.6.1 Tibbles Tibbles sind die vereinfachte Variante eines Dataframes im tidyverse und einfacher zu behandeln. Jede Zeile ist eine Beobachtung bzw. Fall und jede Spalte stellt eine Variable dar. Damit lassen sich Inhalte viel einfacher analysieren und darstellen. students ## age weight height names sex semester study ## 1 19 50 162 Miri female 2 PR ## 2 20 52 168 Johanna female 2 PR ## 3 25 68 177 Egon male 1 CR ## 4 31 76 182 Michel diverse 4 CR # wandelt den data.frame students in das tibble stib um s &lt;- as_tibble(students) is_tibble(s) ## [1] TRUE # Glimpse liefert eine Übersicht über den Datensatz, die entsprechenden Variablen in den Spalten und deren Kodierung glimpse(s) ## Rows: 4 ## Columns: 7 ## $ age &lt;dbl&gt; 19, 20, 25, 31 ## $ weight &lt;dbl&gt; 50, 52, 68, 76 ## $ height &lt;dbl&gt; 162, 168, 177, 182 ## $ names &lt;fct&gt; Miri, Johanna, Egon, Michel ## $ sex &lt;fct&gt; female, female, male, diverse ## $ semester &lt;dbl&gt; 2, 2, 1, 4 ## $ study &lt;fct&gt; PR, PR, CR, CR # Werte lassen sich direkt aus dem tibble mit $ auslesen s$names ## [1] Miri Johanna Egon Michel ## Levels: Egon Johanna Michel Miri "],["daten-bereinigen-tidy-data.html", "Chapter 3 Daten bereinigen (tidy data)", " Chapter 3 Daten bereinigen (tidy data) Eine wichtige Funktion ist es, Daten zu bereinigen. Das Grundprinzip dafür ist, dass jede Zeile eine Beobachtung/ein Fall ist und jede Spalte eine Variable abbildet. Was sich einfach anhört ist in der Praxis leider nicht der Fall. Das Paket Fehlende Werte Fehlende Werte beschreibt R mit NA (non available oder non-assigned). Berechnungen können durch fehlende Werte verfälscht oder nicht ausgeführt werden. Doch dafür gibt es Lösungen. # in diesem Beispiel haben wir unvollständige Werte in unserem Datensatz # Diese sind mit NA codiert und werden so auch im tibble übernommen age &lt;- c(19,NA,25,31) weight &lt;- c(50,52,NA,76) height &lt;- c(162,168,177,NA) name &lt;- c(&quot;Maja&quot;,&quot;Ines&quot;,&quot;David&quot;,&quot;Jerome&quot;) students2 &lt;- data.frame(name, age, weight, height) students2 ## name age weight height ## 1 Maja 19 50 162 ## 2 Ines NA 52 168 ## 3 David 25 NA 177 ## 4 Jerome 31 76 NA s2 &lt;- as_tibble(students2) s2 ## # A tibble: 4 x 4 ## name age weight height ## &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Maja 19 50 162 ## 2 Ines NA 52 168 ## 3 David 25 NA 177 ## 4 Jerome 31 76 NA # Berechnung Mittelwerte # Bei der Berechnung werden die fehlenden Werte als NA bereits herausgerechnet height &lt;- mean(s2$height) height == sum(162,168,177)/3 # beachte, dass durch 3 geteilt wird! ## [1] NA # Sicherer ist es, die fehlenden Werte zu entfernen oder zu unterdrücken. mean(s2$height,na.rm = TRUE) ## [1] 169 3.0.1 tidyr tidyr ist ein umfangreiches Paket zur Datenbereinigung. Es wird vor allem dafür eingesetzt, Datenstrukturen zu verändern. Dies werden wir nur am Rande verwenden. 3.0.2 Tibbles Das Ziel einer guten Datenanalyse ist es, ein Tibble zu erstellen, also einen einfachen Datenframe, in dem jede Zeile eine Beobachtung und jede Spalte eine Variable darstellt. Das geht prinzipiell mit allen Daten. Manchmal müssen dafür die Rohdaten verändert werden. Dazu verwenden wir das Paket tidyR, Cheatsheet tidyR (PDF) "],["daten-importieren.html", "Chapter 4 Daten importieren 4.1 Datenimport 4.2 Übersicht über Daten", " Chapter 4 Daten importieren Wir verwenden den Syntax aus dem tidyverse, d.h. die Kernfunktionen sind Verben, die mit einer Pipe verbunden werden. Sehr gute Anleitungen zum Beispieldatensatz von StarWars gibt es hier und als Tutorial, Cheatsheet data import (PDF). 4.1 Datenimport R kann viele unterschiedlichen Datenquellen verarbeiten (Menü &gt; File &gt; Import Dataset). Die meisten unserer Daten werden wir entweder aus Programmpaketen verwenden oder selbst einlesen. Daten aus Programmpaketen Viele Programmbibliotheken haben bereits Datensätze hinterlegt, die sich direkt aufrufen lassen. Bekannt sind mtcars und starwars, die im tidyverse Paket hinterlegt sind. # Übersicht über Standard-Datensets library(help = &quot;datasets&quot;) ??mtcars mtcars ## mpg cyl disp hp drat wt qsec vs am gear carb ## Mazda RX4 21.0 6 160.0 110 3.90 2.620 16.46 0 1 4 4 ## Mazda RX4 Wag 21.0 6 160.0 110 3.90 2.875 17.02 0 1 4 4 ## Datsun 710 22.8 4 108.0 93 3.85 2.320 18.61 1 1 4 1 ## Hornet 4 Drive 21.4 6 258.0 110 3.08 3.215 19.44 1 0 3 1 ## Hornet Sportabout 18.7 8 360.0 175 3.15 3.440 17.02 0 0 3 2 ## Valiant 18.1 6 225.0 105 2.76 3.460 20.22 1 0 3 1 ## Duster 360 14.3 8 360.0 245 3.21 3.570 15.84 0 0 3 4 ## Merc 240D 24.4 4 146.7 62 3.69 3.190 20.00 1 0 4 2 ## Merc 230 22.8 4 140.8 95 3.92 3.150 22.90 1 0 4 2 ## Merc 280 19.2 6 167.6 123 3.92 3.440 18.30 1 0 4 4 ## Merc 280C 17.8 6 167.6 123 3.92 3.440 18.90 1 0 4 4 ## Merc 450SE 16.4 8 275.8 180 3.07 4.070 17.40 0 0 3 3 ## Merc 450SL 17.3 8 275.8 180 3.07 3.730 17.60 0 0 3 3 ## Merc 450SLC 15.2 8 275.8 180 3.07 3.780 18.00 0 0 3 3 ## Cadillac Fleetwood 10.4 8 472.0 205 2.93 5.250 17.98 0 0 3 4 ## Lincoln Continental 10.4 8 460.0 215 3.00 5.424 17.82 0 0 3 4 ## Chrysler Imperial 14.7 8 440.0 230 3.23 5.345 17.42 0 0 3 4 ## Fiat 128 32.4 4 78.7 66 4.08 2.200 19.47 1 1 4 1 ## Honda Civic 30.4 4 75.7 52 4.93 1.615 18.52 1 1 4 2 ## Toyota Corolla 33.9 4 71.1 65 4.22 1.835 19.90 1 1 4 1 ## Toyota Corona 21.5 4 120.1 97 3.70 2.465 20.01 1 0 3 1 ## Dodge Challenger 15.5 8 318.0 150 2.76 3.520 16.87 0 0 3 2 ## AMC Javelin 15.2 8 304.0 150 3.15 3.435 17.30 0 0 3 2 ## Camaro Z28 13.3 8 350.0 245 3.73 3.840 15.41 0 0 3 4 ## Pontiac Firebird 19.2 8 400.0 175 3.08 3.845 17.05 0 0 3 2 ## Fiat X1-9 27.3 4 79.0 66 4.08 1.935 18.90 1 1 4 1 ## Porsche 914-2 26.0 4 120.3 91 4.43 2.140 16.70 0 1 5 2 ## Lotus Europa 30.4 4 95.1 113 3.77 1.513 16.90 1 1 5 2 ## Ford Pantera L 15.8 8 351.0 264 4.22 3.170 14.50 0 1 5 4 ## Ferrari Dino 19.7 6 145.0 175 3.62 2.770 15.50 0 1 5 6 ## Maserati Bora 15.0 8 301.0 335 3.54 3.570 14.60 0 1 5 8 ## Volvo 142E 21.4 4 121.0 109 4.11 2.780 18.60 1 1 4 2 # Diese Daten werden häufig für Erklärungen verwendet library(tidyverse) ??starwars starwars ## # A tibble: 87 x 14 ## name height mass hair_color skin_color eye_color birth_year sex gender homeworld species films vehicles starships ## &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;lis&gt; &lt;list&gt; &lt;list&gt; ## 1 Luke Skywalker 172 77 blond fair blue 19 male masculine Tatooine Human &lt;chr&gt; &lt;chr&gt; &lt;chr [2]&gt; ## 2 C-3PO 167 75 &lt;NA&gt; gold yellow 112 none masculine Tatooine Droid &lt;chr&gt; &lt;chr&gt; &lt;chr [0]&gt; ## 3 R2-D2 96 32 &lt;NA&gt; white, blue red 33 none masculine Naboo Droid &lt;chr&gt; &lt;chr&gt; &lt;chr [0]&gt; ## 4 Darth Vader 202 136 none white yellow 41.9 male masculine Tatooine Human &lt;chr&gt; &lt;chr&gt; &lt;chr [1]&gt; ## 5 Leia Organa 150 49 brown light brown 19 female feminine Alderaan Human &lt;chr&gt; &lt;chr&gt; &lt;chr [0]&gt; ## 6 Owen Lars 178 120 brown, grey light blue 52 male masculine Tatooine Human &lt;chr&gt; &lt;chr&gt; &lt;chr [0]&gt; ## 7 Beru Whitesun lars 165 75 brown light blue 47 female feminine Tatooine Human &lt;chr&gt; &lt;chr&gt; &lt;chr [0]&gt; ## 8 R5-D4 97 32 &lt;NA&gt; white, red red NA none masculine Tatooine Droid &lt;chr&gt; &lt;chr&gt; &lt;chr [0]&gt; ## 9 Biggs Darklighter 183 84 black light brown 24 male masculine Tatooine Human &lt;chr&gt; &lt;chr&gt; &lt;chr [1]&gt; ## 10 Obi-Wan Kenobi 182 77 auburn, white fair blue-gray 57 male masculine Stewjon Human &lt;chr&gt; &lt;chr&gt; &lt;chr [5]&gt; ## # ... with 77 more rows Daten lokal importieren RStudio bietet eine bequeme Import-Funktion sowohl für Textdaten (CSV) als auch bereits vorhandene Datenstrukturen anderer Programme (EXCEL, SPSS, etc.). File &gt; Import Dataset. Die Funktion eignet sich dann immer besonders gut, wenn die Daten weiterhin lokal bearbeitet werden. Daten online einlesen Am einfachsten lassen sich Daten direkt über eine URL einlesen. Dafür müssen die Daten idealerweise im CSV-Format vorliegen. Das ist eine einfache Textdatei, in der die erste Zeile die Namen der Spalten definiert und jede weitere Zeile einen Datensatz definiert. CSV-Daten sind in der Regel mit einem Komma getrennt und haben keine Leerzeichen. Unser Datensatz students liegt auf Github, beachten Sie hierzu das Codebuch, das den Datensatz erklärt. Wir verwenden den Befehl readr() um die CSV-Datei zu importieren und als s zu bezeichnen. Der Datensatz ist bereits im tidy-Format angelegt, d.h. Spalte entspricht einer Variable und jede Zeile einer Beobachtung. Lesehinweis: von links nach rechts: der Datensatz eines Falls, z.B. library(readr) s &lt;- read_csv(&quot;https://raw.githubusercontent.com/hdm-crpr/226308b_Data_Literacy/main/data/students/students.csv&quot;) ## ## -- Column specification --------------------------------------------------------------------------------------------------------------------- ## cols( ## id = col_double(), ## name = col_double(), ## name_first = col_character(), ## sex = col_double(), ## crpr = col_double(), ## height = col_double(), ## weight = col_double(), ## age = col_double(), ## age_real = col_double(), ## smoke = col_double(), ## phone = col_double(), ## tatoo = col_double(), ## eyes = col_double(), ## hair = col_double(), ## location = col_character(), ## county = col_character() ## ) s ## # A tibble: 38 x 16 ## id name name_first sex crpr height weight age age_real smoke phone tatoo eyes hair location county ## &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 1 1 Charlotte 1 1 167 57 2 21 1 1 2 4 2 Stuttgart BW ## 2 2 2 Jana 1 1 165 55 4 26 1 2 1 2 3 Ludwigsburg BW ## 3 3 3 Lena 1 1 175 65 2 22 1 1 1 3 3 Esslingen BW ## 4 4 4 Serena 1 2 172 59 2 21 1 1 1 1 4 Stuttgart BW ## 5 5 5 Anna 1 2 163 52 1 18 1 2 1 4 4 Kempten BAY ## 6 6 6 Ruth 1 2 177 63 2 20 1 2 1 3 2 Ludwigshafen RP ## 7 7 7 Maria 1 2 172 64 2 20 1 1 2 3 4 Stuttgart BW ## 8 8 8 Eva 1 1 169 59 4 25 1 2 1 4 4 Filderstadt BW ## 9 9 9 Karl 2 1 184 82 4 26 2 2 1 3 4 Leonberg BW ## 10 10 10 Ahmed 2 2 174 70 3 23 2 2 1 3 4 Stuttgart BW ## # ... with 28 more rows 4.2 Übersicht über Daten # prüft, ob der Datensatz ein tibble ist (jede Zeile eine Beobachtung) is_tibble(s) ## [1] TRUE # liefert die Tabellenübersicht in RStudio view(s) # liefert eine Zusammenfassung des Datensatzes glimpse(s) ## Rows: 38 ## Columns: 16 ## $ id &lt;dbl&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 3~ ## $ name &lt;dbl&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 3~ ## $ name_first &lt;chr&gt; &quot;Charlotte&quot;, &quot;Jana&quot;, &quot;Lena&quot;, &quot;Serena&quot;, &quot;Anna&quot;, &quot;Ruth&quot;, &quot;Maria&quot;, &quot;Eva&quot;, &quot;Karl&quot;, &quot;Ahmed&quot;, &quot;Daniel&quot;, &quot;Romina&quot;, &quot;Jara&quot;, &quot;Mar~ ## $ sex &lt;dbl&gt; 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 1, 1, 1, 1, 2, 3, 1, 3, 1, 1, 1, 2, 1, 1, 1, 1, 3, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1 ## $ crpr &lt;dbl&gt; 1, 1, 1, 2, 2, 2, 2, 1, 1, 2, 1, 2, 1, 1, 2, 2, 1, 1, 1, 1, 1, 2, 1, 1, 1, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 2, 2, 1 ## $ height &lt;dbl&gt; 167, 165, 175, 172, 163, 177, 172, 169, 184, 174, 188, 168, 160, 161, 162, 179, 176, 168, 166, 170, 169, 162, 189, 159, ~ ## $ weight &lt;dbl&gt; 57, 55, 65, 59, 52, 63, 64, 59, 82, 70, 78, 62, 59, 57, 58, 66, 64, 54, 54, 52, 58, 52, 83, 49, 50, 54, 52, 65, 59, 62, ~ ## $ age &lt;dbl&gt; 2, 4, 2, 2, 1, 2, 2, 4, 4, 3, 1, 2, 3, 2, 1, 3, 4, 1, 1, 1, 2, 3, 4, 1, 1, 2, 2, 4, 4, 2, 2, 1, 3, 1, 1, 2, 1, 4 ## $ age_real &lt;dbl&gt; 21, 26, 22, 21, 18, 20, 20, 25, 26, 23, 19, 20, 23, 21, 18, 23, 25, 19, 18, 19, 20, 22, 25, 17, 18, 21, 21, 25, 26, 21, ~ ## $ smoke &lt;dbl&gt; 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 2, 1, 1, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 2 ## $ phone &lt;dbl&gt; 1, 2, 1, 1, 2, 2, 1, 2, 2, 2, 1, 1, 1, 2, 1, 2, 2, 1, 2, 2, 1, 1, 2, 1, 2, 1, 1, 2, 1, 2, 1, 1, 1, 2, 2, 2, 2, 1 ## $ tatoo &lt;dbl&gt; 2, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 2, 1, 2, 2, 1, 1, 1, 2, 2, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1 ## $ eyes &lt;dbl&gt; 4, 2, 3, 1, 4, 3, 3, 4, 3, 3, 3, 3, 2, 2, 3, 3, 1, 4, 3, 2, 3, 4, 1, 2, 2, 4, 2, 4, 2, 3, 3, 4, 3, 1, 2, 2, 2, 4 ## $ hair &lt;dbl&gt; 2, 3, 3, 4, 4, 2, 4, 4, 4, 4, 3, 3, 4, 1, 2, 3, 4, 4, 4, 3, 4, 4, 4, 4, 3, 3, 4, 4, 3, 3, 4, 2, 4, 4, 3, 1, 2, 3 ## $ location &lt;chr&gt; &quot;Stuttgart&quot;, &quot;Ludwigsburg&quot;, &quot;Esslingen&quot;, &quot;Stuttgart&quot;, &quot;Kempten&quot;, &quot;Ludwigshafen&quot;, &quot;Stuttgart&quot;, &quot;Filderstadt&quot;, &quot;Leonberg&quot;,~ ## $ county &lt;chr&gt; &quot;BW&quot;, &quot;BW&quot;, &quot;BW&quot;, &quot;BW&quot;, &quot;BAY&quot;, &quot;RP&quot;, &quot;BW&quot;, &quot;BW&quot;, &quot;BW&quot;, &quot;BW&quot;, &quot;BW&quot;, &quot;SA&quot;, &quot;RP&quot;, &quot;BW&quot;, &quot;BW&quot;, &quot;BW&quot;, &quot;BW&quot;, &quot;BW&quot;, &quot;BW&quot;, &quot;BW&quot;,~ # Als Alternative lässt sich skimr einsetzen library(skimr) skim(s) Table 4.1: Data summary Name s Number of rows 38 Number of columns 16 _______________________ Column type frequency: character 3 numeric 13 ________________________ Group variables None Variable type: character skim_variable n_missing complete_rate min max empty n_unique whitespace name_first 0 1 3 9 0 37 0 location 0 1 3 12 0 20 0 county 0 1 2 3 0 6 0 Variable type: numeric skim_variable n_missing complete_rate mean sd p0 p25 p50 p75 p100 hist id 0 1 19.50 11.11 1 10.25 19.5 28.75 38  name 0 1 19.50 11.11 1 10.25 19.5 28.75 38  sex 0 1 1.32 0.62 1 1.00 1.0 1.00 3  crpr 0 1 1.39 0.50 1 1.00 1.0 2.00 2  height 0 1 170.45 8.17 159 163.25 169.0 175.75 189  weight 0 1 60.24 8.48 48 54.00 59.0 64.00 83  age 0 1 2.24 1.13 1 1.00 2.0 3.00 4  age_real 0 1 21.26 2.80 17 19.00 21.0 23.00 27  smoke 0 1 1.24 0.43 1 1.00 1.0 1.00 2  phone 0 1 1.50 0.51 1 1.00 1.5 2.00 2  tatoo 0 1 1.24 0.43 1 1.00 1.0 1.00 2  eyes 0 1 2.74 0.95 1 2.00 3.0 3.00 4  hair 0 1 3.26 0.89 1 3.00 3.5 4.00 4  "],["datenanalyse-mit-dplyr.html", "Chapter 5 Datenanalyse mit dplyr 5.1 Daten selektieren 5.2 Tidydata Tutor", " Chapter 5 Datenanalyse mit dplyr 5.1 Daten selektieren Eine Kernfunktion in der Datenanalyse ist es, Daten nach bestimmten Werten zu selektieren. Es ist wichtig sich zuvor zu überlegen, nach welchen Werte selektiert werden soll. Prinzipiell kann nach Zeilen oder Spalten selektiert werden, Cheatsheet dplyr. 5.1.1 Zeilen manipulieren/filtern Generell: wir erstellen keinen neuen Datensatz, sondern manipulieren den bestehenden Datensatz students. Dazu verwenden wir den Befehl filter(). Damit wird kein neuer Datensatz erstellt, sondern der bestehende Datensatz verändert. # nach Zeilenattribut selektieren, z.B. # tätowierte Frauen aus Stuttgart s %&gt;% filter(sex == 1, tatoo == 2, location == &quot;Stuttgart&quot;) ## # A tibble: 4 x 16 ## id name name_first sex crpr height weight age age_real smoke phone tatoo eyes hair location county ## &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 1 1 Charlotte 1 1 167 57 2 21 1 1 2 4 2 Stuttgart BW ## 2 7 7 Maria 1 2 172 64 2 20 1 1 2 3 4 Stuttgart BW ## 3 20 20 Julia 1 1 170 52 1 19 1 2 2 2 3 Stuttgart BW ## 4 27 27 Merle 1 2 162 52 2 21 1 1 2 2 4 Stuttgart BW # Werte sortieren # nach genauem Alter s %&gt;% arrange(age_real) ## # A tibble: 38 x 16 ## id name name_first sex crpr height weight age age_real smoke phone tatoo eyes hair location county ## &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 24 24 Rana 1 1 159 49 1 17 1 1 1 2 4 Sindelfingen BW ## 2 5 5 Anna 1 2 163 52 1 18 1 2 1 4 4 Kempten BAY ## 3 15 15 Maja 1 2 162 58 1 18 2 1 1 3 2 Ravensburg BW ## 4 19 19 Andrea 3 1 166 54 1 18 2 2 1 3 4 Stuttgart BW ## 5 25 25 Samira 1 1 162 50 1 18 1 2 1 2 3 Stuttgart BW ## 6 32 32 Dana 1 1 172 58 1 18 1 1 1 4 2 Leonberg BW ## 7 34 34 Elisa 1 1 172 66 1 18 1 2 1 1 4 Ulm BW ## 8 35 35 Leonie 1 1 169 57 1 18 1 2 1 2 3 Karlsruhe BW ## 9 11 11 Daniel 2 1 188 78 1 19 2 1 1 3 3 Konstanz BW ## 10 18 18 Mia 1 1 168 54 1 19 1 1 1 4 4 Esslingen BW ## # ... with 28 more rows # absteigend sortieren nach Größe (größter Wert zuerst) s %&gt;% arrange(desc(height)) ## # A tibble: 38 x 16 ## id name name_first sex crpr height weight age age_real smoke phone tatoo eyes hair location county ## &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 23 23 Ben 2 1 189 83 4 25 2 2 2 1 4 Stuttgart BW ## 2 11 11 Daniel 2 1 188 78 1 19 2 1 1 3 3 Konstanz BW ## 3 9 9 Karl 2 1 184 82 4 26 2 2 1 3 4 Leonberg BW ## 4 37 37 Sarah 1 2 184 60 1 19 1 2 1 2 2 Frankfurt HE ## 5 31 31 Luca 2 1 183 74 2 21 1 1 1 3 4 Stuttgart BW ## 6 16 16 Dejan 2 2 179 66 3 23 1 2 1 3 3 Karlsruhe BW ## 7 28 28 Maris 3 2 178 65 4 25 1 2 2 4 4 Hamburg HH ## 8 6 6 Ruth 1 2 177 63 2 20 1 2 1 3 2 Ludwigshafen RP ## 9 29 29 Sina 1 2 177 59 4 26 1 1 1 2 3 Stuttgart BW ## 10 17 17 Ellie 3 1 176 64 4 25 1 2 2 1 4 Ulm BW ## # ... with 28 more rows # Teile des Datensatzes auswählen # selektiere die drei Fälle mit dem höchsten Gewicht s %&gt;% slice_max(weight, n=3) ## # A tibble: 3 x 16 ## id name name_first sex crpr height weight age age_real smoke phone tatoo eyes hair location county ## &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 23 23 Ben 2 1 189 83 4 25 2 2 2 1 4 Stuttgart BW ## 2 9 9 Karl 2 1 184 82 4 26 2 2 1 3 4 Leonberg BW ## 3 11 11 Daniel 2 1 188 78 1 19 2 1 1 3 3 Konstanz BW # zeige die fünf leichtesten Personen s %&gt;% slice_min(weight, n=5) ## # A tibble: 8 x 16 ## id name name_first sex crpr height weight age age_real smoke phone tatoo eyes hair location county ## &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 38 38 Zuleika 1 1 162 48 4 27 2 1 1 4 3 Filderstadt BW ## 2 24 24 Rana 1 1 159 49 1 17 1 1 1 2 4 Sindelfingen BW ## 3 25 25 Samira 1 1 162 50 1 18 1 2 1 2 3 Stuttgart BW ## 4 5 5 Anna 1 2 163 52 1 18 1 2 1 4 4 Kempten BAY ## 5 20 20 Julia 1 1 170 52 1 19 1 2 2 2 3 Stuttgart BW ## 6 22 22 Yara 1 2 162 52 3 22 2 1 2 4 4 Wiesbaden HE ## 7 27 27 Merle 1 2 162 52 2 21 1 1 2 2 4 Stuttgart BW ## 8 36 36 Johanna 1 2 164 52 2 21 1 2 1 2 1 Stuttgart BW # Achtung: hier werden 8 Datensätze ausgegeben, weil fünf Personen jeweils 52 kg wiegen. Wir sind den Code jetzt Zeile für Zeile durchgegangen. Eleganter ist es, wenn dies alles in einem Codechunk passiert. Dazu lassen sich logische Operatoren verbinden. Im Beispiel von filter geht sowohl die Aneinanderreihung der Angaben als auch die Verbindung mit dem logischen Operator &amp;. Für die bessere Lesbarkeit des Codes macht &amp; in diesem Fall mehr Sinn. # Ziel: Wir möchten tätowierte Frauen aus Stuttgart absteigend sortiert nach Größe s %&gt;% filter(sex == 1 &amp; tatoo == 2 &amp; location == &quot;Stuttgart&quot;) %&gt;% arrange(desc(height)) ## # A tibble: 4 x 16 ## id name name_first sex crpr height weight age age_real smoke phone tatoo eyes hair location county ## &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 7 7 Maria 1 2 172 64 2 20 1 1 2 3 4 Stuttgart BW ## 2 20 20 Julia 1 1 170 52 1 19 1 2 2 2 3 Stuttgart BW ## 3 1 1 Charlotte 1 1 167 57 2 21 1 1 2 4 2 Stuttgart BW ## 4 27 27 Merle 1 2 162 52 2 21 1 1 2 2 4 Stuttgart BW # Ergebnis: Von den vier Frauen ist Maria mit 1,72 cm am größten und Merle mit 1,62 cm am kleinsten. 5.1.1.1 Neuen Datensatz erstellen Um einen neuen Datensatz zu erstellen verwenden wir die Zuweisungsfunktion. Das ist wichtig, nur so die Ergebnisse gespeichert werden. # neuen Datensatz der tätowierten Frauen aus Stuttgart erstellen, der nach Alter sortiert ist s_fem_tat_age &lt;- s %&gt;% filter(sex == 1, tatoo == 2, location == &quot;Stuttgart&quot;) %&gt;% arrange(age_real) # der neue Datensatz kann nun eigenständig weiter bearbeitet werden s_fem_tat_age ## # A tibble: 4 x 16 ## id name name_first sex crpr height weight age age_real smoke phone tatoo eyes hair location county ## &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 20 20 Julia 1 1 170 52 1 19 1 2 2 2 3 Stuttgart BW ## 2 7 7 Maria 1 2 172 64 2 20 1 1 2 3 4 Stuttgart BW ## 3 1 1 Charlotte 1 1 167 57 2 21 1 1 2 4 2 Stuttgart BW ## 4 27 27 Merle 1 2 162 52 2 21 1 1 2 2 4 Stuttgart BW 5.1.2 Spalten manipulieren Während sich die Zeilen auf einzelne Fälle beziehen (also in unserem Beispiel Studierende aus dem Datensatz) definieren die Spalten die Variablen des Datensatzes. # Wir lesen das Objekt s erneut ein: s &lt;- read_csv(&quot;https://raw.githubusercontent.com/hdm-crpr/226308b_Data_Literacy/main/data/students/students.csv&quot;) ## ## -- Column specification --------------------------------------------------------------------------------------------------------------------- ## cols( ## id = col_double(), ## name = col_double(), ## name_first = col_character(), ## sex = col_double(), ## crpr = col_double(), ## height = col_double(), ## weight = col_double(), ## age = col_double(), ## age_real = col_double(), ## smoke = col_double(), ## phone = col_double(), ## tatoo = col_double(), ## eyes = col_double(), ## hair = col_double(), ## location = col_character(), ## county = col_character() ## ) # Einzelne Spalten selektieren vornamen &lt;- s %&gt;% select(name_first) vornamen ## # A tibble: 38 x 1 ## name_first ## &lt;chr&gt; ## 1 Charlotte ## 2 Jana ## 3 Lena ## 4 Serena ## 5 Anna ## 6 Ruth ## 7 Maria ## 8 Eva ## 9 Karl ## 10 Ahmed ## # ... with 28 more rows # Mehrere Spalten selektieren crpr_sex &lt;- s %&gt;% select(name_first, sex, crpr) crpr_sex ## # A tibble: 38 x 3 ## name_first sex crpr ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Charlotte 1 1 ## 2 Jana 1 1 ## 3 Lena 1 1 ## 4 Serena 1 2 ## 5 Anna 1 2 ## 6 Ruth 1 2 ## 7 Maria 1 2 ## 8 Eva 1 1 ## 9 Karl 2 1 ## 10 Ahmed 2 2 ## # ... with 28 more rows Häufig ist es wichtig, Variablen umzubenennen, um eine bessere Lesbarkeit der Daten zu erreichen. Dazu verwenden wir den Befehl rename(). Achtung: der neue Wert wird zuerst genannt, dann der Wert, der umgeschrieben werden soll. # Variablen umbenennen. Achtung: der neue Wert muss zuerst in der Funktion genannt werden. s2 &lt;- s %&gt;% rename(geschlecht = sex) %&gt;% select(name, geschlecht) s2 # wir haben zwei Spalten mit name und geschlecht selektiert ## # A tibble: 38 x 2 ## name geschlecht ## &lt;dbl&gt; &lt;dbl&gt; ## 1 1 1 ## 2 2 1 ## 3 3 1 ## 4 4 1 ## 5 5 1 ## 6 6 1 ## 7 7 1 ## 8 8 1 ## 9 9 2 ## 10 10 2 ## # ... with 28 more rows 5.1.3 Werte gruppieren Häufig ist es notwendig, Werte nach bestimmten Gruppen zusammenzufassen. Dies ermöglicht einen besseren Vergleich der Daten. Dazu verwenden wir die Funktion group_by(). Hier können ein oder mehrere Bedingungen angegeben werden. Achtung: wenn eine Gruppe angelegt wird, bleibt diese bestehen. Deshalb sollten Gruppen immer wieder mit ungroup() augelöst werden, wenn sie nicht mehr benötigt werden. # Einfache Zählungen nach einer Variable in neuem Datensatz crpr &lt;- s %&gt;% group_by(crpr) %&gt;% # gruppiert die Werte nach Variable Vertiefung count() %&gt;% # zählt die entsprechenden Fälle ungroup() crpr ## # A tibble: 2 x 2 ## crpr n ## &lt;dbl&gt; &lt;int&gt; ## 1 1 23 ## 2 2 15 # Einfaches Auszählen von Variablen s %&gt;% group_by(age) %&gt;% # gruppiert die Werte nach Variable count() # zählt die entsprechenden Fälle ## # A tibble: 4 x 2 ## # Groups: age [4] ## age n ## &lt;dbl&gt; &lt;int&gt; ## 1 1 12 ## 2 2 13 ## 3 3 5 ## 4 4 8 s %&gt;% group_by(age_real) %&gt;% # gruppiert die Werte nach Variable count() # zählt die entsprechenden Fälle ## # A tibble: 10 x 2 ## # Groups: age_real [10] ## age_real n ## &lt;dbl&gt; &lt;int&gt; ## 1 17 1 ## 2 18 7 ## 3 19 4 ## 4 20 4 ## 5 21 8 ## 6 22 2 ## 7 23 4 ## 8 25 4 ## 9 26 3 ## 10 27 1 Natürlich lassen sich auch zwei Variablen gruppieren und zählen. # Zwei Variablen gruppieren s %&gt;% group_by (crpr, tatoo) %&gt;% # gruppiert die Werte nach Variable count() # zählt die entsprechenden Fälle ## # A tibble: 4 x 3 ## # Groups: crpr, tatoo [4] ## crpr tatoo n ## &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; ## 1 1 1 18 ## 2 1 2 5 ## 3 2 1 11 ## 4 2 2 4 5.1.4 Mittelwerte berechnen und speichern Häufig interessieren uns nicht die Einzelwerte, wie oben, sondern aggregierte Mittelwerte. Ein Mittelwert (mean) teilt die Summe aller Werte durch ihre Anzahl und liefert so einen besseren Vergleich. Es ist einer der einfachsten Werte der deskriptiven Statistk, den wir berechnen können. In diesem Beispiel wollen wir die Mittelwerte berechnen und verwenden dazu die summarize() Funktion. # direkter Aufruf des Mittelwert des Alters aus dem Datensatz s mean(s$age_real) ## [1] 21.26316 # damit wird der Mittelwert aller Werte einer Variable berechnet. # Durchschnittsgröße nach Geschlecht s %&gt;% group_by(sex) %&gt;% # gruppiert nach Geschlecht summarize(mean(height)) %&gt;% # berechnet die Durchschnittsgröße round(digits = 1) %&gt;% # verwendet nur eine Dezimalstelle ungroup() ## # A tibble: 3 x 2 ## sex `mean(height)` ## &lt;dbl&gt; &lt;dbl&gt; ## 1 1 168. ## 2 2 183. ## 3 3 173. Mutate: neue Variablen anlegen und berechnen Mit mutate() lassen sich neue Variablen anlegen bzw. bestehende Werte umrechnen. Das ist wichtig, um Werte ins Verhältnis zu setzen. Verhältniswerte nennen wir auch Prozent, d.h. Prozentwerte messen den Anteil eines Wertes von 100. Prozentwerte geben immer Verhältnisse an und sind so besser zu verstehen. Dazu wird der gesuchte Wert mit der Gesamtzahl geteilt und mit 100 multipliziert. Zudem lassen sich mit mutate() die Variablen und Beobachtungen umcodieren. s %&gt;% count(sex) %&gt;% # count erstellt eine neue Spalte mit &quot;n&quot; für die Häufigkeiten mutate(percent = n/sum(n) * 100) %&gt;% # mutate erstellt eine neue Spalte &quot;percent&quot; und berechnet dort die Häufigkeiten von n, geteilt durch die Summe von n multipliziert mal 100. round(digits = 2) ## # A tibble: 3 x 3 ## sex n percent ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 29 76.3 ## 2 2 6 15.8 ## 3 3 3 7.89 # rundet die Werte auf 2 Dezimalstellen Wir sehen jetzt, dass rund drei Viertel der Studierenden weiblich sind. Wir können dies mit allen numerisch codierten Variablen machen. Merksatz: als n werden immer einfache Häufigkeiten (frequencies) ausgegeben. Häufig ist es hilfreich, für die Ausgabe nur noch die Spalten zu wählen, die auch sinnvoll angezeigt werden können. # Ziel: wir wollen den prozentualen Anteil der jeweiligen Vertiefungen prozentual sehen und dafür auch die entsprechenden Werte umcodieren, damit diese leichter lesbar sind. s %&gt;% group_by(crpr) %&gt;% # gruppiert die Werte nach Variable Vertiefung count() %&gt;% # zählt die entsprechenden Fälle als n ungroup() %&gt;% # löst die Gruppe auf mutate(Anteil = n/sum(n)*100) %&gt;% # legt die Variable Anteil an round(digits = 2) %&gt;% # rundet auf 2 Kommastellen mutate(Vertiefung = recode(crpr, &quot;1&quot; = &quot;Crossmedia-Redaktion&quot;, &quot;2&quot; = &quot;Public Relations&quot;)) %&gt;% # recodiert die Werte der alten Variable crpr in eine neue Kategorie &quot;Vertiefung&quot; und benennt die entsprechenden Werte 1 und 2 entsprechend um. select(Vertiefung, Anteil) ## # A tibble: 2 x 2 ## Vertiefung Anteil ## &lt;chr&gt; &lt;dbl&gt; ## 1 Crossmedia-Redaktion 60.5 ## 2 Public Relations 39.5 # zeigt uns nur die beiden verlangten Werte Im Beispiel oben sieht man, wie schnell sich eine Aussage über die Verteilung der Vertiefung treffen lässt. 5.1.4.1 Komplexere Beziehungen berechnen Beispielweise interessiert uns der BMI, Body-Mass-Index. Hier wird die Körpergröße ins Verhältnis zur Größe gesetzt, die Formel wird als Gewicht / Körpergröße in Metern im Quadrat definiert. Ein BMI von 19-24 (Frauen) und 20-25 (Männer) gilt als passender Wert. # Berechnung des Bodymass-Indexes # Wir müssen zunächst die Körpergröße in Meter umrechnen, da sich sonst die Werte verfälschen, denn im Original-Datensatz sind die Werte in cm angegeben. bmi &lt;- s %&gt;% # mutate(height = height/100) %&gt;% # teile die Angabe in cm durch 100, um die Angabe in Meter zu erhalten. mutate(bmi = weight/(height*height)) %&gt;% # lege eine neue Variable bmi an select(name_first, sex, height, bmi) %&gt;% # nimm nur die ersten drei Spalten mutate(across(where(is.numeric), round, 2)) # rundet alle numerischen Werte auf zwei Dezimalen bmi ## # A tibble: 38 x 4 ## name_first sex height bmi ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Charlotte 1 1.67 20.4 ## 2 Jana 1 1.65 20.2 ## 3 Lena 1 1.75 21.2 ## 4 Serena 1 1.72 19.9 ## 5 Anna 1 1.63 19.6 ## 6 Ruth 1 1.77 20.1 ## 7 Maria 1 1.72 21.6 ## 8 Eva 1 1.69 20.7 ## 9 Karl 2 1.84 24.2 ## 10 Ahmed 2 1.74 23.1 ## # ... with 28 more rows # Wie verteilt sich die Smartphone-Nutzung auf Männer und Frauen? s %&gt;% group_by(sex) %&gt;% count(phone) %&gt;% mutate(Prozent = n/38*100) %&gt;% mutate(Geschlecht = recode(sex, &quot;1&quot; = &quot;weiblich&quot;, &quot;2&quot; = &quot;mönnlich&quot;, &quot;3&quot; = &quot;divers&quot;)) %&gt;% ungroup() %&gt;% mutate(Smartphone = recode(phone, &quot;1&quot; = &quot;ios&quot;, &quot;2&quot; = &quot;android&quot;)) %&gt;% select(Geschlecht, Smartphone, Prozent) %&gt;% mutate(across(where(is.numeric), round, 2)) ## # A tibble: 5 x 3 ## Geschlecht Smartphone Prozent ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 weiblich ios 44.7 ## 2 weiblich android 31.6 ## 3 mönnlich ios 5.26 ## 4 mönnlich android 10.5 ## 5 divers android 7.89 5.1.5 Spalten umbennen Manchmal ist es sinnvoll, Werte umzubennen, um diese für Publikationen besser lesbar zu machen. Dazu gibt es zwei Kategorien, nämlich Spaltenbezeichnungen und einzelne codierte Werte. Spalten lassen sich durch rename() verändern, dabei muss der neue Spaltenname zuerst genannt werden. s &lt;- read_csv(&quot;https://raw.githubusercontent.com/hdm-crpr/226308b_Data_Literacy/main/data/students/students.csv&quot;) ## ## -- Column specification --------------------------------------------------------------------------------------------------------------------- ## cols( ## id = col_double(), ## name = col_double(), ## name_first = col_character(), ## sex = col_double(), ## crpr = col_double(), ## height = col_double(), ## weight = col_double(), ## age = col_double(), ## age_real = col_double(), ## smoke = col_double(), ## phone = col_double(), ## tatoo = col_double(), ## eyes = col_double(), ## hair = col_double(), ## location = col_character(), ## county = col_character() ## ) # Wie verteilt sich die Smartphone-Nutzung auf Männer und Frauen? smart &lt;- s %&gt;% group_by(sex) %&gt;% # gruppiert nach Geschlecht count(phone) %&gt;% # zählt die gleichen Nennungen für sex und phone mutate(n = n/38*100) %&gt;% # berechnet den prozentualen Anteil round(digits = 1) %&gt;% # rundet die Werte auf eine Nachkommastelle ungroup() smart ## # A tibble: 5 x 3 ## sex phone n ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 1 44.7 ## 2 1 2 31.6 ## 3 2 1 5.3 ## 4 2 2 10.5 ## 5 3 2 7.9 smart &lt;- smart %&gt;% # zunächst nennen wir die Spalten um rename(Geschlecht = sex, Smartphone = phone, Prozent = n) # %&gt;% smart ## # A tibble: 5 x 3 ## Geschlecht Smartphone Prozent ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 1 44.7 ## 2 1 2 31.6 ## 3 2 1 5.3 ## 4 2 2 10.5 ## 5 3 2 7.9 5.1.6 Werte recodieren bzw. umbennen Wir wollen den Datensatz smart nun besser lesbar machen. Dazu wollen wir die einzelnen Zeilenwerte umbenennen. Dazu ist es hilfreich, das Codebuch zu verwenden! Das Codebuch sagt uns: Geschlecht 1 = weiblich, 2 = männlich, 3 = divers und Smartphone 1 = Android, 2 = iOS. Wenn wir die einzelnen Daten umkodieren, müssen wir ein neues Objekt anlegen. Dazu verwenden wir die Funktion mutate() in Verbindung mit recode(). smart # die bereits berechneten Werte verwenden wir weiter. ## # A tibble: 5 x 3 ## Geschlecht Smartphone Prozent ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 1 44.7 ## 2 1 2 31.6 ## 3 2 1 5.3 ## 4 2 2 10.5 ## 5 3 2 7.9 smart_table &lt;- smart %&gt;% mutate(Geschlecht=recode (Geschlecht, &quot;1&quot; = &quot;female&quot;, &quot;2&quot; = &quot;male&quot;, &quot;3&quot; = &quot;diverse&quot;)) %&gt;% mutate(Smartphone=recode (Smartphone, &quot;1&quot; = &quot;Android&quot;, &quot;2&quot; = &quot;iOS&quot;)) smart_table ## # A tibble: 5 x 3 ## Geschlecht Smartphone Prozent ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 female Android 44.7 ## 2 female iOS 31.6 ## 3 male Android 5.3 ## 4 male iOS 10.5 ## 5 diverse iOS 7.9 5.1.7 Exkurs: Tabellen einfach erstellen Wir haben jetzt die Werte umkodiert: damit lassen sich die Tabellenwerte viel einfacher lesen. Tabellen lassen sich in Markdown noch schöner darstellen, dazu benötigen wir die Programmbibliothek kableExtra(). kable() ist in knitr integriert und verwendet vorgefertigte Themes, die sich aber anpassen lassen. KableExtra müssten Sie ggf. noch installieren. library(kableExtra) ## Warning: package &#39;kableExtra&#39; was built under R version 3.6.3 ## ## Attaching package: &#39;kableExtra&#39; ## The following object is masked from &#39;package:dplyr&#39;: ## ## group_rows # minimal style smart_table %&gt;% # nimm den Datensatz kbl() %&gt;% # mach eine schöne Tabelle kable_minimal() # mit dem minimal theme Geschlecht Smartphone Prozent female Android 44.7 female iOS 31.6 male Android 5.3 male iOS 10.5 diverse iOS 7.9 T_Sex_Phone &lt;- smart_table %&gt;% # erstelle ein neues Objekt kbl(caption = &quot;Geschlechtsverteilung und Smartphone-Nutzung&quot;) %&gt;% # füge eine Tabellenüberschrift hinzu kable_classic(full_width = T, html_font = &quot;Cambria&quot;) # nutze die gesamte Breite und verwende die Schriftart Cambria. T_Sex_Phone # das ist das formatierte Objekt! (#tab:Great tables with kable)Geschlechtsverteilung und Smartphone-Nutzung Geschlecht Smartphone Prozent female Android 44.7 female iOS 31.6 male Android 5.3 male iOS 10.5 diverse iOS 7.9 Die oben erstellte Tabelle lässt sich auch direkt in Markdown-Dokumente einbetten: (#tab:Great tables with kable)Geschlechtsverteilung und Smartphone-Nutzung Geschlecht Smartphone Prozent female Android 44.7 female iOS 31.6 male Android 5.3 male iOS 10.5 diverse iOS 7.9 Vielleicht merken Sie jetzt bereits, wie viel einfacher Publikation einer Forschungsarbeit werden kann, wenn Sie es mit komplexeren Analysen und Daten zu tun haben. Sie müssen sich nicht mehr um die umständliche Erstellung von Tabellen in Word beschäftigen, sondern können sich direkt auf die Daten fokussieren und diese dann direkt in das Dokument einbetten. 5.1.8 Kür: verschiedene Bedingungen kombinieren Wer etwas sicherer im Umgang mit R ist, kann auch beginnen, verschiedene Parameter zu verbinden. Dazu verwenden wir z.B. logische Operatoren. Wir möchten z.B. nur weibliche CR-Vertieferinnen, die ein android smartphone verwenden und größer sind als 175cm. # Datensatz einlesen s &lt;- read_csv(&quot;https://raw.githubusercontent.com/hdm-crpr/226308b_Data_Literacy/main/data/students/students.csv&quot;) ## ## -- Column specification --------------------------------------------------------------------------------------------------------------------- ## cols( ## id = col_double(), ## name = col_double(), ## name_first = col_character(), ## sex = col_double(), ## crpr = col_double(), ## height = col_double(), ## weight = col_double(), ## age = col_double(), ## age_real = col_double(), ## smoke = col_double(), ## phone = col_double(), ## tatoo = col_double(), ## eyes = col_double(), ## hair = col_double(), ## location = col_character(), ## county = col_character() ## ) androids175 &lt;- s %&gt;% filter(sex != &quot;2&quot; &amp; phone == &quot;1&quot; &amp; height&gt;=&quot;175&quot; &amp; crpr == &quot;1&quot;) %&gt;% select(name_first, sex, crpr, phone, height) androids175 ## # A tibble: 1 x 5 ## name_first sex crpr phone height ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Lena 1 1 1 175 # Wer möchte, kann das noch etwas schöner machen a175 &lt;- androids175 %&gt;% rename(Name = &quot;name_first&quot;, Geschlecht = &quot;sex&quot;, Smartphone = &quot;phone&quot;, Vertiefung = &quot;crpr&quot;, Größe = &quot;height&quot;) a175 ## # A tibble: 1 x 5 ## Name Geschlecht Vertiefung Smartphone Größe ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Lena 1 1 1 175 5.1.9 Zusammenfassung Daten manipulieren Mit dem dyplr-Paket lassen sich Datensätze leicht verändern, wenn diese in einem tidydata-Format (tibble) vorliegen. Dazu sind alle Beobachtungen in einer Zeile, alle Variablen in den Spalten angelegt. Die wichtigsten Funktionen dafür sind: filter(): nach Zeilenwerte selektieren select(): einzelne Spalten selektieren group_by(): Teilgruppen nach bestimmten Variablen erstellen count(): Einzelne Fälle zählen summarize(): Fälle zusammenfassen rename(): Spalten umbenennen recode(): Werte umkodieren 5.2 Tidydata Tutor Eine ganz tolle Möglichkeit, sich die Funktionen vom tidyverse zu verdeutlichen bietet der TidydataTutor. Hier lassen sich die einzelnen Schritte für die Datenmanipulation Schritt für Schritt nachvollziehen und so der eigene Umgang mit Code verbessern. Beispiel Starwars "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
